/**
 * Script de build otimizado para Windows
 * Cria instalador MSI/EXE profissional
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

class WindowsBuilder {
  constructor() {
    this.projectRoot = __dirname;
    this.buildDir = path.join(this.projectRoot, 'build');
    this.distDir = path.join(this.projectRoot, 'dist');
    this.outputDir = path.join(this.projectRoot, 'release');
    
    this.config = {
      appName: 'IPTV Player Pro',
      appId: 'com.iptvplayerpro.app',
      version: '1.0.0',
      description: 'Reprodutor IPTV profissional com interface Netflix',
      author: 'IPTV Player Pro Team',
      copyright: '¬© 2024 IPTV Player Pro. Todos os direitos reservados.',
      homepage: 'https://iptvplayerpro.com',
      supportUrl: 'https://iptvplayerpro.com/support'
    };
  }

  /**
   * Executa o processo completo de build
   */
  async buildForWindows() {
    console.log('üöÄ Iniciando build para Windows...\n');

    try {
      await this.prepareBuild();
      await this.buildReactApp();
      await this.optimizeAssets();
      await this.createElectronPackage();
      await this.createInstaller();
      await this.createPortableVersion();
      await this.generateChecksums();
      await this.createReleaseNotes();
      
      console.log('\n‚úÖ Build para Windows conclu√≠do com sucesso!');
      this.showBuildSummary();
      
    } catch (error) {
      console.error('\n‚ùå Erro durante o build:', error.message);
      process.exit(1);
    }
  }

  /**
   * Prepara ambiente para build
   */
  async prepareBuild() {
    console.log('üìã Preparando ambiente de build...');
    
    // Criar diret√≥rios necess√°rios
    this.ensureDirectory(this.outputDir);
    this.ensureDirectory(path.join(this.outputDir, 'installers'));
    this.ensureDirectory(path.join(this.outputDir, 'portable'));
    
    // Limpar builds anteriores
    if (fs.existsSync(this.distDir)) {
      console.log('   Limpando builds anteriores...');
      this.removeDirectory(this.distDir);
    }
    
    // Verificar depend√™ncias
    console.log('   Verificando depend√™ncias...');
    this.checkDependencies();
    
    console.log('   ‚úÖ Ambiente preparado\n');
  }

  /**
   * Build da aplica√ß√£o React
   */
  async buildReactApp() {
    console.log('‚öõÔ∏è Compilando aplica√ß√£o React...');
    
    try {
      // Definir vari√°veis de ambiente para produ√ß√£o
      process.env.NODE_ENV = 'production';
      process.env.GENERATE_SOURCEMAP = 'false';
      process.env.INLINE_RUNTIME_CHUNK = 'false';
      
      // Executar build do React
      console.log('   Executando npm run build...');
      execSync('npm run build', { 
        stdio: 'pipe',
        cwd: this.projectRoot 
      });
      
      console.log('   ‚úÖ React build conclu√≠do\n');
      
    } catch (error) {
      throw new Error(`Falha no build do React: ${error.message}`);
    }
  }

  /**
   * Otimiza assets para produ√ß√£o
   */
  async optimizeAssets() {
    console.log('üé® Otimizando assets...');
    
    try {
      const staticDir = path.join(this.buildDir, 'static');
      
      if (fs.existsSync(staticDir)) {
        // Verificar tamanhos dos arquivos
        const jsFiles = this.getFilesWithExtension(staticDir, '.js');
        const cssFiles = this.getFilesWithExtension(staticDir, '.css');
        
        let totalJSSize = 0;
        let totalCSSSize = 0;
        
        jsFiles.forEach(file => {
          totalJSSize += fs.statSync(file).size;
        });
        
        cssFiles.forEach(file => {
          totalCSSSize += fs.statSync(file).size;
        });
        
        console.log(`   JS: ${jsFiles.length} arquivos (${(totalJSSize / 1024 / 1024).toFixed(2)} MB)`);
        console.log(`   CSS: ${cssFiles.length} arquivos (${(totalCSSSize / 1024 / 1024).toFixed(2)} MB)`);
      }
      
      console.log('   ‚úÖ Assets otimizados\n');
      
    } catch (error) {
      console.warn('   ‚ö†Ô∏è Aviso na otimiza√ß√£o de assets:', error.message);
    }
  }

  /**
   * Cria pacote Electron
   */
  async createElectronPackage() {
    console.log('üì¶ Criando pacote Electron...');
    
    try {
      // Atualizar configura√ß√£o do electron-builder
      this.updateElectronBuilderConfig();
      
      // Executar electron-builder para Windows
      console.log('   Executando electron-builder...');
      execSync('npx electron-builder --win --x64', {
        stdio: 'pipe',
        cwd: this.projectRoot
      });
      
      console.log('   ‚úÖ Pacote Electron criado\n');
      
    } catch (error) {
      throw new Error(`Falha na cria√ß√£o do pacote Electron: ${error.message}`);
    }
  }

  /**
   * Cria instalador MSI/EXE
   */
  async createInstaller() {
    console.log('üíø Criando instalador...');
    
    try {
      // Verificar se o execut√°vel foi criado
      const exePath = path.join(this.distDir, 'win-unpacked', `${this.config.appName}.exe`);
      
      if (!fs.existsSync(exePath)) {
        throw new Error('Execut√°vel n√£o encontrado');
      }
      
      // Copiar instalador para diret√≥rio de release
      const installerSource = path.join(this.distDir, `${this.config.appName} Setup 1.0.0.exe`);
      const installerDest = path.join(this.outputDir, 'installers', 'IPTV-Player-Pro-Setup.exe');
      
      if (fs.existsSync(installerSource)) {
        fs.copyFileSync(installerSource, installerDest);
        console.log('   ‚úÖ Instalador EXE criado');
      }
      
      // Verificar se MSI foi criado
      const msiSource = path.join(this.distDir, `${this.config.appName} Setup 1.0.0.msi`);
      const msiDest = path.join(this.outputDir, 'installers', 'IPTV-Player-Pro-Setup.msi');
      
      if (fs.existsSync(msiSource)) {
        fs.copyFileSync(msiSource, msiDest);
        console.log('   ‚úÖ Instalador MSI criado');
      }
      
      console.log('   ‚úÖ Instaladores criados\n');
      
    } catch (error) {
      console.warn('   ‚ö†Ô∏è Aviso na cria√ß√£o do instalador:', error.message);
    }
  }

  /**
   * Cria vers√£o port√°vel
   */
  async createPortableVersion() {
    console.log('üìÅ Criando vers√£o port√°vel...');
    
    try {
      const unpackedDir = path.join(this.distDir, 'win-unpacked');
      const portableDir = path.join(this.outputDir, 'portable', 'IPTV-Player-Pro-Portable');
      
      if (fs.existsSync(unpackedDir)) {
        // Copiar arquivos para vers√£o port√°vel
        this.copyDirectory(unpackedDir, portableDir);
        
        // Criar arquivo de configura√ß√£o port√°vel
        const portableConfig = {
          portable: true,
          dataDir: './data',
          configDir: './config'
        };
        
        fs.writeFileSync(
          path.join(portableDir, 'portable.json'),
          JSON.stringify(portableConfig, null, 2)
        );
        
        // Criar diret√≥rios de dados
        this.ensureDirectory(path.join(portableDir, 'data'));
        this.ensureDirectory(path.join(portableDir, 'config'));
        
        // Criar arquivo README para vers√£o port√°vel
        this.createPortableReadme(portableDir);
        
        // Criar arquivo ZIP da vers√£o port√°vel
        await this.createZipArchive(portableDir, path.join(this.outputDir, 'IPTV-Player-Pro-Portable.zip'));
        
        console.log('   ‚úÖ Vers√£o port√°vel criada\n');
      }
      
    } catch (error) {
      console.warn('   ‚ö†Ô∏è Aviso na cria√ß√£o da vers√£o port√°vel:', error.message);
    }
  }

  /**
   * Gera checksums dos arquivos
   */
  async generateChecksums() {
    console.log('üîê Gerando checksums...');
    
    try {
      const crypto = require('crypto');
      const checksums = {};
      
      // Arquivos para verificar
      const filesToCheck = [
        path.join(this.outputDir, 'installers', 'IPTV-Player-Pro-Setup.exe'),
        path.join(this.outputDir, 'installers', 'IPTV-Player-Pro-Setup.msi'),
        path.join(this.outputDir, 'IPTV-Player-Pro-Portable.zip')
      ];
      
      for (const file of filesToCheck) {
        if (fs.existsSync(file)) {
          const data = fs.readFileSync(file);
          const hash = crypto.createHash('sha256').update(data).digest('hex');
          const fileName = path.basename(file);
          checksums[fileName] = hash;
          console.log(`   ${fileName}: ${hash}`);
        }
      }
      
      // Salvar checksums em arquivo
      fs.writeFileSync(
        path.join(this.outputDir, 'checksums.txt'),
        Object.entries(checksums)
          .map(([file, hash]) => `${hash}  ${file}`)
          .join('\n')
      );
      
      console.log('   ‚úÖ Checksums gerados\n');
      
    } catch (error) {
      console.warn('   ‚ö†Ô∏è Aviso na gera√ß√£o de checksums:', error.message);
    }
  }

  /**
   * Cria notas de release
   */
  async createReleaseNotes() {
    console.log('üìù Criando notas de release...');
    
    const releaseNotes = `# IPTV Player Pro v${this.config.version}

## üéâ Lan√ßamento Inicial

### ‚ú® Funcionalidades Principais

- **Interface Netflix-Style**: Design moderno e intuitivo
- **Suporte Xtream Codes**: Integra√ß√£o completa com API Xtream Codes
- **Player Avan√ßado**: Suporte a m√∫ltiplos formatos (HLS, DASH, MP4, etc.)
- **Navega√ß√£o Inteligente**: Mouse, teclado e controle remoto
- **Busca Avan√ßada**: Sistema de busca inteligente com filtros
- **Favoritos e Hist√≥rico**: Gerenciamento completo de conte√∫do
- **Controle Parental**: Sistema de PIN e restri√ß√µes
- **Multi-perfil**: Suporte a m√∫ltiplos usu√°rios

### üîß Funcionalidades T√©cnicas

- **Arquitetura Electron + React**: Performance e compatibilidade
- **SQLite**: Banco de dados local para persist√™ncia
- **Cache Inteligente**: Otimiza√ß√£o de performance
- **Navega√ß√£o por Teclado**: Atalhos completos
- **Sistema de Notifica√ß√µes**: Feedback em tempo real

### üìã Requisitos do Sistema

- **Sistema Operacional**: Windows 10 ou Windows 11
- **Mem√≥ria RAM**: M√≠nimo 4GB, recomendado 8GB
- **Espa√ßo em Disco**: 500MB livres
- **Conex√£o**: Internet banda larga para streaming

### üì¶ Arquivos de Instala√ß√£o

- **IPTV-Player-Pro-Setup.exe**: Instalador completo (recomendado)
- **IPTV-Player-Pro-Setup.msi**: Instalador MSI para empresas
- **IPTV-Player-Pro-Portable.zip**: Vers√£o port√°vel (n√£o requer instala√ß√£o)

### üîê Verifica√ß√£o de Integridade

Verifique a integridade dos arquivos usando os checksums SHA-256 fornecidos no arquivo \`checksums.txt\`.

### üìû Suporte

- **Email**: suporte@iptvplayerpro.com
- **Discord**: [Servidor da Comunidade](https://discord.gg/iptvplayerpro)
- **Documenta√ß√£o**: [Manual do Usu√°rio](MANUAL_USUARIO.md)

### üêõ Problemas Conhecidos

- Primeira execu√ß√£o pode demorar alguns segundos para carregar
- Alguns antiv√≠rus podem dar falso positivo (aplica√ß√£o n√£o assinada)
- Performance pode variar dependendo das especifica√ß√µes do hardware

### üîÑ Pr√≥ximas Atualiza√ß√µes

- Grava√ß√£o de programas
- Sincroniza√ß√£o entre dispositivos
- Temas personaliz√°veis
- Plugins de terceiros
- Suporte a mais formatos de playlist

---

**Data de Lan√ßamento**: ${new Date().toLocaleDateString('pt-BR')}
**Tamanho do Download**: ~300MB
**Licen√ßa**: MIT License
`;

    fs.writeFileSync(path.join(this.outputDir, 'RELEASE_NOTES.md'), releaseNotes);
    console.log('   ‚úÖ Notas de release criadas\n');
  }

  /**
   * Atualiza configura√ß√£o do electron-builder
   */
  updateElectronBuilderConfig() {
    const packageJsonPath = path.join(this.projectRoot, 'package.json');
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    
    packageJson.build = {
      appId: this.config.appId,
      productName: this.config.appName,
      directories: {
        output: 'dist'
      },
      files: [
        'build/**/*',
        'node_modules/**/*',
        'public/electron.js',
        'public/preload.js'
      ],
      win: {
        target: [
          {
            target: 'nsis',
            arch: ['x64']
          },
          {
            target: 'msi',
            arch: ['x64']
          }
        ],
        icon: 'public/icon.ico',
        publisherName: this.config.author,
        verifyUpdateCodeSignature: false
      },
      nsis: {
        oneClick: false,
        allowToChangeInstallationDirectory: true,
        createDesktopShortcut: true,
        createStartMenuShortcut: true,
        shortcutName: this.config.appName,
        include: 'build/installer.nsh'
      },
      msi: {
        oneClick: false,
        perMachine: true
      }
    };
    
    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
  }

  /**
   * Cria README para vers√£o port√°vel
   */
  createPortableReadme(portableDir) {
    const readme = `# IPTV Player Pro - Vers√£o Port√°vel

## üöÄ Como Usar

1. **Extraia** todos os arquivos para uma pasta de sua escolha
2. **Execute** o arquivo "IPTV Player Pro.exe"
3. **Configure** sua conex√£o IPTV na primeira execu√ß√£o

## üìÅ Estrutura de Arquivos

- **IPTV Player Pro.exe**: Execut√°vel principal
- **data/**: Dados do usu√°rio (favoritos, hist√≥rico)
- **config/**: Configura√ß√µes da aplica√ß√£o
- **portable.json**: Configura√ß√£o da vers√£o port√°vel

## ‚öôÔ∏è Configura√ß√µes

Esta vers√£o port√°vel salva todas as configura√ß√µes e dados na pr√≥pria pasta, permitindo:

- **Uso em m√∫ltiplos computadores** sem instala√ß√£o
- **Backup f√°cil** copiando a pasta inteira
- **N√£o deixa rastros** no sistema

## üîß Requisitos

- Windows 10 ou Windows 11 (64-bit)
- 4GB RAM (8GB recomendado)
- Conex√£o com internet para streaming

## üìû Suporte

- Email: suporte@iptvplayerpro.com
- Discord: https://discord.gg/iptvplayerpro
- Manual: MANUAL_USUARIO.md

---
IPTV Player Pro v${this.config.version} - Vers√£o Port√°vel
`;

    fs.writeFileSync(path.join(portableDir, 'README.txt'), readme);
  }

  /**
   * Mostra resumo do build
   */
  showBuildSummary() {
    console.log('\nüìä Resumo do Build:');
    console.log('==========================================');
    
    const outputFiles = [];
    
    // Verificar arquivos criados
    const installerExe = path.join(this.outputDir, 'installers', 'IPTV-Player-Pro-Setup.exe');
    const installerMsi = path.join(this.outputDir, 'installers', 'IPTV-Player-Pro-Setup.msi');
    const portableZip = path.join(this.outputDir, 'IPTV-Player-Pro-Portable.zip');
    
    if (fs.existsSync(installerExe)) {
      const size = (fs.statSync(installerExe).size / 1024 / 1024).toFixed(2);
      outputFiles.push(`‚úÖ Instalador EXE: ${size} MB`);
    }
    
    if (fs.existsSync(installerMsi)) {
      const size = (fs.statSync(installerMsi).size / 1024 / 1024).toFixed(2);
      outputFiles.push(`‚úÖ Instalador MSI: ${size} MB`);
    }
    
    if (fs.existsSync(portableZip)) {
      const size = (fs.statSync(portableZip).size / 1024 / 1024).toFixed(2);
      outputFiles.push(`‚úÖ Vers√£o Port√°vel: ${size} MB`);
    }
    
    outputFiles.forEach(file => console.log(file));
    
    console.log('\nüìÅ Arquivos dispon√≠veis em:', this.outputDir);
    console.log('\nüéâ Build conclu√≠do com sucesso!');
  }

  // M√©todos auxiliares

  ensureDirectory(dir) {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  }

  removeDirectory(dir) {
    if (fs.existsSync(dir)) {
      fs.rmSync(dir, { recursive: true, force: true });
    }
  }

  copyDirectory(src, dest) {
    this.ensureDirectory(dest);
    const files = fs.readdirSync(src);
    
    for (const file of files) {
      const srcPath = path.join(src, file);
      const destPath = path.join(dest, file);
      
      if (fs.statSync(srcPath).isDirectory()) {
        this.copyDirectory(srcPath, destPath);
      } else {
        fs.copyFileSync(srcPath, destPath);
      }
    }
  }

  getFilesWithExtension(dir, extension) {
    const files = [];
    
    if (!fs.existsSync(dir)) return files;
    
    const dirFiles = fs.readdirSync(dir);
    
    for (const file of dirFiles) {
      const filePath = path.join(dir, file);
      const stats = fs.statSync(filePath);
      
      if (stats.isDirectory()) {
        files.push(...this.getFilesWithExtension(filePath, extension));
      } else if (file.endsWith(extension)) {
        files.push(filePath);
      }
    }
    
    return files;
  }

  checkDependencies() {
    const requiredCommands = ['npm', 'npx'];
    
    for (const cmd of requiredCommands) {
      try {
        execSync(`${cmd} --version`, { stdio: 'pipe' });
      } catch (error) {
        throw new Error(`Comando necess√°rio n√£o encontrado: ${cmd}`);
      }
    }
  }

  async createZipArchive(sourceDir, outputPath) {
    try {
      // Usar PowerShell para criar ZIP no Windows
      const command = `powershell -command "Compress-Archive -Path '${sourceDir}\\*' -DestinationPath '${outputPath}' -Force"`;
      execSync(command, { stdio: 'pipe' });
    } catch (error) {
      console.warn('Erro ao criar arquivo ZIP:', error.message);
    }
  }
}

// Executar build se chamado diretamente
if (require.main === module) {
  const builder = new WindowsBuilder();
  builder.buildForWindows().catch(error => {
    console.error('Erro durante o build:', error);
    process.exit(1);
  });
}

module.exports = WindowsBuilder;

